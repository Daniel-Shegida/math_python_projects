
Функции пакета numpy

Выполнил: Шегида Даниил Леонидович

Создание массива из элементов 1 4 5 8 с типом float:
a = np.array([1, 4, 5, 8], float)
[1. 4. 5. 8.]
создание массива с использованием синтаксиса range:
np.arange(1, 6, 2, dtype=int):
[1 3 5]
возвращяет массив нулей или единиц с указанной размерностью:
np.ones((2,3), dtype=float)
[[1. 1. 1.]
 [1. 1. 1.]]
np.zeros(7, dtype=int
[0 0 0 0 0 0 0]
Возвращает массив единиц, с размерностью выбранного массива:
np.zeros_like(a):
[[0. 0. 0.]
 [0. 0. 0.]]
np.ones_like(a):
[[1. 1. 1.]
 [1. 1. 1.]]
Возвращяет единичный массив:
np.identity(4, dtype=float):
[[1. 0. 0. 0.]
 [0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]]
Взвращяет единичный массив с двигом к:
np.eye(4, k=1, dtype=float):
[[0. 1. 0. 0.]
 [0. 0. 1. 0.]
 [0. 0. 0. 1.]
 [0. 0. 0. 0.]]
возвращение размерности массива:
a = np.array([[1, 2, 3], [4, 5, 6]], float)
a.shape)
(2, 3)
Переделывает массив в выбранную размерность:
np.array(range(10), float)
a.reshape((5, 2))
[[0. 1.]
 [2. 3.]
 [4. 5.]
 [6. 7.]
 [8. 9.]]
Возвращяет тип хранимых переменных в массиве:
a = np.array(range(10), float)
a.dtype)
float64
Возвращяет копию массива:
a = np.array([1, 2, 3], float)
b = a
c = a.copy()
a[0] = 0
[0. 2. 3.]
[1. 2. 3.]
Полиморф массива в лист:
a = np.array([1, 2, 3], float)
a.tolist()
[1.0, 2.0, 3.0]
Полиморф массива в бинарную строкут:
a = np.array([1, 2, 3], float)
s = a.tostring()
b'\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08@'
Наполняет массив следующей переменной::
a = np.array([1, 2, 3], float)
a.fill(0)
[0. 0. 0.]
 Два или более массива могут быть соединены вместе:
a = np.array([1,2], float)
b = np.array([3,4,5,6], float)
c = np.array([7,8,9], float)
np.concatenate((a, b, c))
[1. 2. 3. 4. 5. 6. 7. 8. 9.]
Команда транспонирования двухмерных массивов:
a = np.array(range(6), float).reshape((2, 3))
a.transpose()
[[0. 1. 2.]
 [3. 4. 5.]]
[[0. 1. 2.]
 [3. 4. 5.]]
Возвращяет 1-мерный массив из многомерного:
a = np.array([[1, 2, 3], [4, 5, 6]], float)
a.flatten()
[[1. 2. 3.]
 [4. 5. 6.]]
Все математические операции применяются по элементам друг к другу:
a = np.array([1,2,3], float)
b = np.array([5,2,6], float)
a + b
[6. 4. 9.]
Двухмерные массивы также умножаются по элементам:
a = np.array([[1,2], [3,4]], float)
b = np.array([[2,0], [1,3]], float)
a * b
[[ 2.  0.]
 [ 3. 12.]]
# Библиотека поддерживает моножество функций, такие как abs, sign, sqrt, log, log10, exp, sin, cos, tan, arcsin, arccos, arctan, sinh, cosh, tanh, arcsinh, arccosh, and arctanh.
a = np.array([1, 4, 9], float)
np.sqrt(a)
[1. 2. 3.]
 Функции floor, ceil, and rint округляют вниз, вверх или ближайшее:
a = np.array([1.1, 1.5, 1.9], float)
np.floor(a)
[1. 1. 1.]
np.ceil(a)
[2. 2. 2.]
np.rint(a)
[1. 2. 2.]
 Возвращяет сумму или умножение всех элементов массива
a = np.array([2, 4, 3], float)
a.sum()
9.0
a.prod()
24.0
 Возвращяет среднее массива:
a = np.array([2, 1, 9], float)
a.mean()
4.0
 возвращяет квадратичное отклонение:
a = np.array([2, 1, 9], float)
a.var()
12.666666666666666
 Возвращяет отклонение:
a = np.array([2, 1, 9], float)
a.std()
3.559026084010437
 ВВозвращение максимального или минимального элемента:
a = np.array([2, 1, 9], float)
a.min()
1.0
a.max()
9.0
 Возврашение индекса максимального или минимального элемента массива:
a = np.array([2, 1, 9], float)
a.argmin()
1
a.argmax()
2
 Сортировка массиовов:
a = np.array([6, 2, 5, -1, 0], float)
a.sort()
None
Возможность выставлять максимальные или минимальные величины в массивах
a = np.array([6, 2, 5, -1, 0], float)
a.clip(0, 5)
[5. 2. 5. 0. 0.]
Возвращяет уникальные элементы массива:
a = np.array([1, 1, 4, 5, 5, 5, 7], float)
np.unique(a)
[1. 4. 5. 7.]
Возвращяет знааачение по диагонали:
a = np.array([[1, 2], [3, 4]], float)
a.diagonal()
[1. 4.]
Можно поставить логическое выражение для любого или для всех элементов:
a = np.array([1, 3, 0], float)
any(a > 2)
True
all(a > 2)
False
# Более сложные булевы выражения можно сделать с помошью команд special functions logical_and, logical_or, and logical_not.
a = np.array([1, 3, 0], float)
np.logical_and(a > 0, a < 3)
[ True False False]
b = np.array([True, False, True], bool)
np.logical_not(b)
[False  True False]
c = np.array([False, True, False], bool)
np.logical_or(b, c)
[ True  True  True]
Применение логических фильтров к массивам..
a = np.array([[6, 4], [5, 9]], float)
a >= 6
[[ True False]
 [False  True]]
take берет из массива к которому принимаается элементы по индексам, которые указываются в переменной
a = np.array([2, 4, 6, 8], float)
b = np.array([0, 0, 1, 3, 2, 1], int)
a.take(b)
[2. 2. 4. 8. 6. 4.]
функция put заменяет элементы в массиве а по индексам получаемые из первого массива элементами, получаемыми из 2 массивав нашем случае из b
a = np.array([0, 1, 2, 3, 4, 5], float)
b = np.array([9, 8, 7], float)
a.put([0, 3], b)
None
Для нахождения определителя используется дот (a1 * b1 + a2 * b2...)
a = np.array([1, 2, 3], float)
b = np.array([0, 1, 1], float)
np.dot(a, b)
5.0
dot также применим для произведения  матриц:
a = np.array([[0, 1], [2, 3]], float)
b = np.array([2, 3], float)
c = np.array([[1, 1], [4, 0]], float)
np.dot(b, a)
[ 6. 11.]
Для более привычных произведений массивов, можно использовать inner, outer, and cross:
a = np.array([1, 4, 0], float)
b = np.array([2, 2, 1], float)
np.outer(a, b)
[[2. 2. 1.]
 [8. 8. 4.]
 [0. 0. 0.]]
np.inner(a, b)
10.0
np.cross(a, b)
[ 4. -1. -6.]
Для нахождения определителя, нужно воспользоваться сабмудлем linalg. командой det
a = np.array([[4, 2, 0], [9, 3, 7], [1, 2, 1]], float)
np.linalg.det(a)
-48.00000000000003
инверсия матрицы можно найти
a = np.array([[4, 2, 0], [9, 3, 7], [1, 2, 1]], float)
b = np.linalg.inv(a)
[[ 0.22916667  0.04166667 -0.29166667]
 [ 0.04166667 -0.08333333  0.58333333]
 [-0.3125      0.125       0.125     ]]
с помощью NumPy можно получить кэфициэнты, введя коэфициенты уравнения s
np.poly([-1, 1, 1, 10])
[  1. -11.   9.  11. -10.]
Обратная ситуация, можно получить корни введя коэфициэнты 
np.roots([1, 4, -2, 3])
[-4.5797401 +0.j          0.28987005+0.75566815j  0.28987005-0.75566815j]
коэфиэнты массивов могут быть интегрированы 
np.polyint([1, 1, 1, 1])
[0.25       0.33333333 0.5        1.         0.        ]
и наоборот, можно получить производную 
np.polyder([1./4., 1./3., 1./2., 1., 0.])
[1. 1. 1. 1.]
В функцию можно подставить число с 
np.polyval([1, -2, 0, 2], 4)
34
Можно, если выразиться проще, то оно по точкам в 2 мерном пространстве сощданным по массивам х и у пытается найти полином  что проходит сквозь эти точки
x = [1, 2, 3, 4, 5, 6, 7, 8]
y = [0, 2, 1, 3, 7, 10, 11, 19]
np.polyfit(x, y, 2)
[ 0.375      -0.88690476  1.05357143]
